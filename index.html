<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Corre Luisa</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #444;
      touch-action: none;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    body.fullscreen {
      background: #87ceeb;
    }
    #phone-container {
      width: 800px;
      height: 450px;
      background: #000;
      border-radius: 20px;
      border: 12px solid #333;
      position: relative;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    .fullscreen #phone-container {
      width: 100%;
      height: 100%;
      border-radius: 0;
      border: none;
      box-shadow: none;
    }
    #game-area {
      width: 100%;
      height: 100%;
      position: relative;
      background: #87ceeb;
      overflow: hidden;
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block;
    }
    #score {
      position: absolute;
      left: 18px;
      top: 18px;
      font-family: Arial, sans-serif;
      font-size: 1.8em;
      color: #fff;
      text-shadow: 1px 2px 4px #333, 0 0 10px #1e90ff;
      z-index: 2;
    }
    #gameover {
      position: absolute;
      left: 0; top: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 2em;
      text-align: center;
      z-index: 3;
      display: none;
    }    #gameover button {
      margin-top: 20px;
      font-size: 0.9em;
      padding: 12px 28px;
      border: none;
      border-radius: 10px;
      background: #ffdb58;
      color: #444;
      font-weight: bold;
      box-shadow: 2px 2px 8px #222;
      cursor: pointer;
    }
    #rotate {
      display: none;
      position: absolute;
      left: 0; top: 0; width: 100%; height: 100%;
      background: #222;
      color: #fff;
      z-index: 5;
      font-family: Arial, sans-serif;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 1.5em;
    }
    #fullscreen-btn {
      position: absolute;
      top: 18px;
      right: 18px;
      width: 40px;
      height: 40px;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      cursor: pointer;
      border: none;
      outline: none;
    }
    #fullscreen-btn:before {
      content: "";
      width: 20px;
      height: 20px;
      border: 2px solid white;
      border-radius: 2px;
      display: block;
    }
    .fullscreen #fullscreen-btn:before {
      width: 16px;
      height: 16px;
    }
    @media (max-width: 800px) {
      #phone-container {
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
      }
    }
  </style>
</head>
<body>
<div id="phone-container">
  <div id="game-area">
    <div id="rotate">Por favor, gire o celular para a horizontal (paisagem) para jogar!</div>
    <div id="score">Conchas: 0</div>
    <button id="fullscreen-btn" aria-label="Tela cheia"></button>
    <div id="gameover">
      <div id="finalmsg"></div>
      <button onclick="restart()">Jogar novamente</button>
    </div>
    <canvas id="game"></canvas>
  </div>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function isLandscape() { 
  // Em tela cheia no mobile, verifica a orientação real
  if (document.body.classList.contains('fullscreen') && 
     /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    return window.innerWidth > window.innerHeight;
  }
  return true; // Sempre em paisagem na simulação de celular
}

function setCanvasSize() {
  if (document.body.classList.contains('fullscreen')) {
    // Em tela cheia, usa o tamanho da janela
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  } else {
    // Dimensões fixas para simular um dispositivo móvel
    canvas.width = 800;
    canvas.height = 450;
  }
}
setCanvasSize();
window.addEventListener('resize', setCanvasSize);

let w = () => canvas.width, h = () => canvas.height;
let GROUND_Y = () => h() * 0.82;
let GRAVITY = () => h() * 0.0026;
let JUMP_VELOCITY = () => -h() * 0.042; // Mais alto
let GIRL_W = () => w() * 0.08, GIRL_H = () => h() * 0.32;
let JACARE_W = () => w() * 0.13, JACARE_H = () => h() * 0.23;
let SHELL_SIZE = () => w() * 0.045;
let OBSTACLE_W = () => w() * 0.045, OBSTACLE_H = () => h() * 0.10;
let POWERUP_SIZE = () => w() * 0.06; // Tamanho dos itens de poder

// Constantes para controle da frequência dos itens
const SHELL_FREQUENCY_MIN = 0.45; // Mínimo intervalo para conchas (em larguras de tela)
const SHELL_FREQUENCY_MAX = 0.6;  // Máximo intervalo para conchas
const OBSTACLE_FREQUENCY_MIN = 0.55; // Mínimo intervalo para obstáculos
const OBSTACLE_FREQUENCY_MAX = 0.5;  // Máximo intervalo para obstáculos
const POWERUP_FREQUENCY_MIN = 4.0;   // Mínimo intervalo para power-ups (muito mais raro)
const POWERUP_FREQUENCY_MAX = 6.0;   // Máximo intervalo para power-ups

// Velocidade máxima do jogo (relativa à largura da tela)
const MAX_SPEED = 10;  // Velocidade máxima (dobro da velocidade inicial)

// Duração dos power-ups em milissegundos
const MAGNET_DURATION = 8000;  // Duração do imã: 8 segundos
const SHIELD_DURATION = 6000;  // Duração do escudo: 6 segundos

let girl, jacare, shells, obstacles, score, gameover, bgOffset, speed, touchActive, started;
let powerups = []; // Array para armazenar os itens de poder (imã e escudo)
let magnetActive = false; // Estado do poder imã
let magnetEndTime = 0; // Tempo de término do poder imã
let shieldActive = false; // Estado do poder escudo
let shieldEndTime = 0; // Tempo de término do poder escudo
let lastObstacleX = 0; // Rastrear a posição do último obstáculo

function startGame() {
  setCanvasSize();  jacare = {
    x: w() * 0.03, // Posição inicial mais à esquerda
    y: GROUND_Y() - JACARE_H() + 12,
    w: JACARE_W(),
    h: JACARE_H()
    // Removido jacare.speed, não é mais usado
  };
  girl = {
    x: jacare.x + jacare.w + w() * 0.30, // Posição inicial mais à direita (aumentado de 0.20 para 0.30)
    y: GROUND_Y() - GIRL_H(),
    vy: 0,
    w: GIRL_W(),
    h: GIRL_H(),
    jumping: false
  };  shells = [];
  obstacles = [];
  powerups = []; // Reiniciar array de itens de poder
  magnetActive = false; // Desativar imã
  shieldActive = false; // Desativar escudo
  score = 0;
  speed = w() * 0.009; // Velocidade inicial (metade da velocidade máxima)
  bgOffset = 0;
  started = false;
  gameover = false;
  // Reiniciar tempos dos poderes
  magnetEndTime = 0;
  shieldEndTime = 0;
  lastObstacleX = 0; // Reiniciar a posição do último obstáculo
  document.getElementById('score').innerText = "Conchas: 0";
  document.getElementById('gameover').style.display = 'none';
  spawnShell();
  spawnObstacle();
  spawnPowerup(); // Iniciar geração de itens de poder
  requestAnimationFrame(loop);
}

// Shells (conchas)
function spawnShell() {
  const interval = Math.random() * (w() * SHELL_FREQUENCY_MAX) + w() * SHELL_FREQUENCY_MIN;
  setTimeout(() => {
    if (!gameover && isLandscape()) {
      shells.push({
        x: w() + SHELL_SIZE(),
        y: GROUND_Y() - SHELL_SIZE() - Math.random() * (h() * 0.15),
        w: SHELL_SIZE(),
        h: SHELL_SIZE()
      });
      spawnShell();
    }
  }, interval / speed * 16);
}

// Obstáculos (pedras)
function spawnObstacle() {
  const interval = Math.random() * (w() * OBSTACLE_FREQUENCY_MAX) + w() * OBSTACLE_FREQUENCY_MIN;
  setTimeout(() => {
    if (!gameover && isLandscape()) {
      // Verificar se há espaço suficiente para um novo obstáculo
      const minSpaceBetweenObstacles = w() * 0.5; // Espaço mínimo de 50% da largura da tela
      
      // Se não houver obstáculos ou o último obstáculo já estiver suficientemente distante
      if (obstacles.length === 0 || 
          (lastObstacleX - (w() + OBSTACLE_W())) < -minSpaceBetweenObstacles) {
        
        // Criar novo obstáculo
        const newObstacle = {
          x: w() + OBSTACLE_W(),
          y: GROUND_Y() - OBSTACLE_H() + 8,
          w: OBSTACLE_W(),
          h: OBSTACLE_H()
        };
        
        obstacles.push(newObstacle);
        lastObstacleX = newObstacle.x; // Atualizar a posição do último obstáculo
      }
      
      // Programar próxima verificação
      spawnObstacle();
    }
  }, interval / speed * 13);
}

// Itens de poder (imã e escudo)
function spawnPowerup() {
  // Intervalo muito mais longo para os power-ups (bem mais raros)
  const interval = Math.random() * (w() * POWERUP_FREQUENCY_MAX) + w() * POWERUP_FREQUENCY_MIN;
  setTimeout(() => {
    if (!gameover && isLandscape()) {
      // Tipo aleatório: 0 para imã, 1 para escudo
      const type = Math.floor(Math.random() * 2);
      powerups.push({
        x: w() + POWERUP_SIZE(),
        y: GROUND_Y() - POWERUP_SIZE() - Math.random() * (h() * 0.15),
        w: POWERUP_SIZE(),
        h: POWERUP_SIZE(),
        type: type // 0 = imã, 1 = escudo
      });
      spawnPowerup();
    }
  }, interval / speed * 50); // Multiplicador muito maior para tornar os power-ups bem mais raros
}

function drawBeach() {
  ctx.fillStyle = '#87ceeb'; // Céu
  ctx.fillRect(0, 0, w(), h());
  ctx.fillStyle = '#1e90ff'; // Mar
  ctx.fillRect(0, GROUND_Y() - h()*0.06, w(), h()*0.13);
  ctx.fillStyle = '#ffdb58'; // Areia
  ctx.fillRect(0, GROUND_Y(), w(), h() - GROUND_Y());
  ctx.strokeStyle = '#edd382'; // Linhas areia
  ctx.lineWidth = 4;
  for(let i=0; i<9; i++) {
    let lx = ((bgOffset + i*200) % w());
    ctx.beginPath();
    ctx.moveTo(lx, GROUND_Y() + h()*0.03);
    ctx.lineTo(lx + 70, h());
    ctx.stroke();
  }
}

function drawGirl() {
  ctx.save();
  ctx.translate(girl.x + girl.w/2, girl.y + girl.h/2);
  const jumpAmt = girl.jumping ? 0.12 : 0;
  ctx.rotate(jumpAmt * Math.sin(Date.now()/110));
  
  // Efeito de escudo quando ativo
  if (shieldActive) {
    ctx.beginPath();
    ctx.arc(0, 0, girl.w * 1.2, 0, 2 * Math.PI);
    ctx.fillStyle = 'rgba(147, 112, 219, 0.3)';
    ctx.fill();
    
    // Borda animada do escudo
    ctx.strokeStyle = 'rgba(255, 255, 255, ' + (0.5 + Math.sin(Date.now()/150) * 0.5) + ')';
    ctx.lineWidth = 3;
    ctx.stroke();
  }
  
  // Efeito de imã quando ativo
  if (magnetActive) {
    ctx.beginPath();
    // Linhas onduladas ao redor da menina
    for (let i = 0; i < 360; i += 40) {
      const rad = i * Math.PI / 180;
      const wave = Math.sin(Date.now()/200 + i/20) * 5;
      const x1 = Math.cos(rad) * (girl.w * 1.3);
      const y1 = Math.sin(rad) * (girl.w * 1.3);
      const x2 = Math.cos(rad) * (girl.w * 1.6 + wave);
      const y2 = Math.sin(rad) * (girl.w * 1.6 + wave);
      
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.strokeStyle = 'rgba(30, 144, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  ctx.fillStyle = '#ffb6c1';
  ctx.fillRect(-girl.w/2, -girl.h/2, girl.w, girl.h);
  ctx.beginPath();
  ctx.arc(0, -girl.h/2.2, girl.w/2.7, 0, 2 * Math.PI);
  ctx.fillStyle = '#ffe4e1';
  ctx.fill();
  ctx.fillStyle = '#c66900';
  ctx.fillRect(-girl.w/2, girl.h/2 - 8, girl.w*0.20, 10);
  ctx.fillRect(girl.w/2 - girl.w*0.20, girl.h/2 - 8, girl.w*0.20, 10);
  ctx.beginPath();
  ctx.moveTo(-girl.w/2.5, -girl.h/2.2);
  ctx.lineTo(-girl.w/1.8, -girl.h/1.8);
  ctx.lineTo(-girl.w/4, -girl.h/2.8);
  ctx.closePath();
  ctx.fillStyle = '#8b5c2d';
  ctx.fill();
  ctx.restore();
}

function drawJacare() {
  ctx.save();
  ctx.translate(jacare.x + jacare.w/2, jacare.y + jacare.h/2);
  ctx.fillStyle = '#228B22';
  ctx.fillRect(-jacare.w/2, -jacare.h/2, jacare.w, jacare.h*0.55);
  ctx.beginPath();
  ctx.ellipse(jacare.w*0.37, -jacare.h*0.1, jacare.w*0.23, jacare.h*0.25, 0, 0, 2*Math.PI);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-jacare.w/2, jacare.h*0.05);
  ctx.quadraticCurveTo(-jacare.w*0.75, jacare.h*0.07, -jacare.w/2, jacare.h*0.30);
  ctx.lineTo(-jacare.w/2+10, jacare.h*0.10);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.arc(jacare.w*0.47, -jacare.h*0.18, jacare.w*0.06, 0, 2*Math.PI);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(jacare.w*0.50, -jacare.h*0.18, jacare.w*0.025, 0, 2*Math.PI);
  ctx.fillStyle = '#111';
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.fillRect(jacare.w*0.55, -jacare.h*0.03, 6, 7);
  ctx.fillRect(jacare.w*0.52, 0, 6, 7);
  ctx.restore();
}

function drawShell(shell) {
  ctx.save();
  ctx.translate(shell.x + shell.w/2, shell.y + shell.h/2);
  ctx.beginPath();
  ctx.arc(0, 0, shell.w/2.3, 0, Math.PI, true);
  ctx.lineTo(-shell.w/2.3, shell.h/2.7);
  ctx.quadraticCurveTo(0, shell.h/1.7, shell.w/2.3, shell.h/2.7);
  ctx.closePath();
  ctx.fillStyle = '#ffb347';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, shell.h/2.7);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-shell.w/6, 0);
  ctx.lineTo(-shell.w/9, shell.h/2.7);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(shell.w/6, 0);
  ctx.lineTo(shell.w/9, shell.h/2.7);
  ctx.stroke();
  ctx.restore();
}

function drawObstacle(obs) {
  ctx.save();
  ctx.translate(obs.x + obs.w/2, obs.y + obs.h/2);
  ctx.beginPath();
  ctx.ellipse(0, obs.h/5, obs.w/2, obs.h/2.2, 0, 0, 2 * Math.PI);
  ctx.fillStyle = '#888';
  ctx.shadowColor = "#222";
  ctx.shadowBlur = 4;
  ctx.fill();
  ctx.restore();
}

// Desenhar item de poder (imã ou escudo)
function drawPowerup(powerup) {
  ctx.save();
  ctx.translate(powerup.x + powerup.w/2, powerup.y + powerup.h/2);
  
  // Efeito de rotação suave
  ctx.rotate(Date.now() / 800);
  
  if (powerup.type === 0) { // Imã
    // Desenha imã
    ctx.fillStyle = '#1e90ff';
    ctx.beginPath();
    ctx.arc(0, 0, powerup.w/2.5, 0, 2 * Math.PI);
    ctx.fill();
    
    // Ferradura do imã
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(0, -powerup.h/8, powerup.w/4, Math.PI, 0, true);
    ctx.fill();
    
    // Polos do imã
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-powerup.w/4, -powerup.h/5, powerup.w/10, powerup.h/3.5);
    ctx.fillRect(powerup.w/4 - powerup.w/10, -powerup.h/5, powerup.w/10, powerup.h/3.5);
  } else { // Escudo
    // Desenha escudo
    ctx.fillStyle = '#9370db';
    ctx.beginPath();
    ctx.arc(0, 0, powerup.w/2.5, 0, 2 * Math.PI);
    ctx.fill();
    
    // Desenho do escudo
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, powerup.w/4, 0, 2 * Math.PI);
    ctx.stroke();
    
    // Detalhes do escudo
    ctx.beginPath();
    ctx.moveTo(0, -powerup.h/5);
    ctx.lineTo(0, powerup.h/5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-powerup.w/5, 0);
    ctx.lineTo(powerup.w/5, 0);
    ctx.stroke();
  }
  
  // Efeito brilhante
  ctx.shadowColor = powerup.type === 0 ? "#1e90ff" : "#9370db";
  ctx.shadowBlur = 10;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, powerup.w/2.5, 0, 2 * Math.PI);
  ctx.stroke();
  
  ctx.restore();
}

// Desenha indicadores dos poderes ativos
function drawPowerIndicators() {
  // Posição dos indicadores no canto superior direito
  const startX = w() - 20;
  const startY = 20;
  const iconSize = w() * 0.035;
  const spacing = iconSize * 1.5;
  
  // Desenhar ícone do imã se estiver ativo
  if (magnetActive) {
    const timeLeft = (magnetEndTime - Date.now()) / 1000; // Tempo restante em segundos
    drawPowerIcon(startX - iconSize, startY, iconSize, 0, timeLeft, MAGNET_DURATION/1000);
  }
  
  // Desenhar ícone do escudo se estiver ativo
  if (shieldActive) {
    const timeLeft = (shieldEndTime - Date.now()) / 1000; // Tempo restante em segundos
    drawPowerIcon(startX - iconSize, startY + spacing, iconSize, 1, timeLeft, SHIELD_DURATION/1000);
  }
}

// Desenha um ícone de poder com barra de tempo
function drawPowerIcon(x, y, size, type, timeLeft, maxTime) {
  ctx.save();
  ctx.translate(x, y);
  
  // Desenha o círculo de fundo
  ctx.fillStyle = type === 0 ? 'rgba(30, 144, 255, 0.7)' : 'rgba(147, 112, 219, 0.7)';
  ctx.beginPath();
  ctx.arc(0, 0, size, 0, 2 * Math.PI);
  ctx.fill();
  
  // Desenha o ícone
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  
  if (type === 0) { // Imã
    // Ferradura do imã
    ctx.beginPath();
    ctx.arc(0, -size/8, size/3, Math.PI, 0, true);
    ctx.stroke();
    
    // Polos do imã
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-size/3, -size/4, size/6, size/2);
    ctx.fillRect(size/3 - size/6, -size/4, size/6, size/2);
  } else { // Escudo
    ctx.beginPath();
    ctx.arc(0, 0, size/2, 0, 2 * Math.PI);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, -size/2);
    ctx.lineTo(0, size/2);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(-size/2, 0);
    ctx.lineTo(size/2, 0);
    ctx.stroke();
  }
  
  // Desenha barra de tempo
  const percentage = timeLeft / maxTime;
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.arc(0, 0, size * 0.8, -Math.PI/2, -Math.PI/2 + percentage * 2 * Math.PI, false);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function loop() {
  if (gameover || !isLandscape()) return;
  ctx.clearRect(0,0,w(),h());

  bgOffset -= speed * 2;
  if(bgOffset < -w()) bgOffset += w();

  drawBeach();

  // Verificar se os poderes estão ativos
  const currentTime = Date.now();
  if (magnetActive && currentTime > magnetEndTime) {
    magnetActive = false;
  }
  if (shieldActive && currentTime > shieldEndTime) {
    shieldActive = false;
  }

  // Menina física
  girl.vy += GRAVITY();
  girl.y += girl.vy;
  if (girl.y + girl.h >= GROUND_Y()) {
    girl.y = GROUND_Y() - girl.h;
    girl.vy = 0;
    girl.jumping = false;
  }
  // Jacaré persegue a menina, mas fica mais afastado
  let dist = girl.x - jacare.x - jacare.w * 0.2;
  let minDist = girl.w * 2.5; // Aumentando a distância mínima para 2.5x a largura da menina
  if (dist > minDist) {
    jacare.x += Math.min(speed * 0.75, dist * 0.05); // Velocidade de perseguição mais lenta
  }
  // Obstáculos
  for (let o of obstacles) o.x -= speed;
  obstacles = obstacles.filter(o => {
    // Manter apenas obstáculos visíveis na tela
    const isVisible = o.x + o.w > 0;
    // Quando um obstáculo sai da tela, atualizar a variável lastObstacleX
    if (!isVisible && lastObstacleX === o.x) {
      lastObstacleX = 0; // Resetar o valor para permitir novos obstáculos
    }
    return isVisible;
  });

  // Colisão menina/obstáculo
  for (let i = 0; i < obstacles.length; i++) {
    let obs = obstacles[i];
    if (rectsCollide(girl, obs)) {
      // Se o escudo estiver ativo, não há colisão com obstáculos
      if (!shieldActive) {
        gameOver("Você tropeçou em uma pedra!");
        return;
      }
    }
  }

  // Power-ups
  for (let p of powerups) p.x -= speed;
  powerups = powerups.filter(p => p.x + p.w > 0);

  // Colisão menina/power-up
  for (let i = powerups.length-1; i >= 0; i--) {
    let p = powerups[i];
    if (rectsCollide(girl, p)) {
      powerups.splice(i, 1);
      
      if (p.type === 0) { // Imã
        magnetActive = true;
        magnetEndTime = Date.now() + MAGNET_DURATION;
      } else { // Escudo
        shieldActive = true;
        shieldEndTime = Date.now() + SHIELD_DURATION;
      }
    }
  }

  // Shells
  for (let s of shells) s.x -= speed;
  shells = shells.filter(s => s.x + s.w > 0);

  // Efeito do imã de conchas
  if (magnetActive) {
    for (let s of shells) {
      // Calcular distância entre a menina e a concha
      const dx = (girl.x + girl.w/2) - (s.x + s.w/2);
      const dy = (girl.y + girl.h/2) - (s.y + s.h/2);
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      // Se a concha estiver próxima, atraí-la para a menina
      if (distance < w() * 0.3) // Distância de atração: 30% da largura da tela
        s.x += dx * 0.07; // Velocidade de atração
        s.y += dy * 0.07;
    }
  }
  // Colisão menina/shell
  for (let i = shells.length-1; i >= 0; i--) {
    let s = shells[i];
    if (rectsCollide(girl,s)) {
      shells.splice(i,1);
      score++;
      document.getElementById('score').innerText = "Conchas: " + score;
      
      // Aumentar velocidade até o limite máximo
      if (speed < MAX_SPEED) {
        speed += w() * 0.00037;
        // Limitar a velocidade ao máximo definido
        if (speed > MAX_SPEED) {
          speed = MAX_SPEED;
        }
      }
      // Jacaré não fica mais rápido!
    }
  }

  // Colisão jacaré/menina
  if (rectsCollide(jacare, girl)) {
    // Se o escudo estiver ativo, não há colisão com o jacaré
    if (!shieldActive) {
      gameOver("O jacaré pegou você!");
      return;
    }
  }

  // Desenha shells
  for (let s of shells) drawShell(s);

  // Desenha obstáculos
  for (let o of obstacles) drawObstacle(o);
  
  // Desenha power-ups
  for (let p of powerups) drawPowerup(p);

  // Desenha personagens
  drawGirl();
  drawJacare();
  
  // Desenha indicadores dos poderes ativos
  drawPowerIndicators();

  requestAnimationFrame(loop);
}

function rectsCollide(a, b) {
  return !(a.x + a.w < b.x + 10 ||
           a.x > b.x + b.w - 10 ||
           a.y + a.h < b.y + 10 ||
           a.y > b.y + b.h - 10);
}

// Controles (Toque ou Tecla)
function jump() {
  if (!girl.jumping && !gameover && isLandscape()) {
    girl.vy = JUMP_VELOCITY();
    girl.jumping = true;
    started = true;
  }
}
canvas.addEventListener('touchstart', function(e){
  e.preventDefault();
  // Evite pular se o toque foi no botão de tela cheia
  const fsButton = document.getElementById('fullscreen-btn');
  const touch = e.touches[0];
  const fsRect = fsButton.getBoundingClientRect();
  
  if (touch.clientX >= fsRect.left && touch.clientX <= fsRect.right &&
      touch.clientY >= fsRect.top && touch.clientY <= fsRect.bottom) {
    return;
  }
  
  jump();
}, {passive:false});
canvas.addEventListener('pointerdown', function(e){
  e.preventDefault();
  // Evite pular se o clique foi no botão de tela cheia
  const fsButton = document.getElementById('fullscreen-btn');
  const fsRect = fsButton.getBoundingClientRect();
  
  if (e.clientX >= fsRect.left && e.clientX <= fsRect.right &&
      e.clientY >= fsRect.top && e.clientY <= fsRect.bottom) {
    return;
  }
  
  jump();
});
window.addEventListener('keydown', function(e){
  if (e.code === "Space" || e.code === "ArrowUp") jump();
});

function gameOver(msg) {
  gameover = true;
  document.getElementById('finalmsg').innerText =
    (msg ? msg+"\n":"") + `Você coletou ${score} conchinha${score==1?'':'s'}!`;
  document.getElementById('gameover').style.display = 'flex';
}

function restart() {
  startGame();
}

// Orientação tela
function checkOrientation() {
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && 
      document.body.classList.contains('fullscreen')) {
    // Em modo tela cheia no celular, verifica orientação real
    if (!isLandscape()) {
      document.getElementById('rotate').style.display = "flex";
      canvas.style.display = "none";
      document.getElementById('score').style.display = "none";
      return;
    }
  }
  
  // Exibe o jogo
  document.getElementById('rotate').style.display = "none";
  canvas.style.display = "";
  document.getElementById('score').style.display = "";
  
  if (gameover) return;
  if (!started) startGame();
}
window.addEventListener('resize', checkOrientation);

// Funções para tela cheia
function toggleFullScreen() {
  if (!document.fullscreenElement && 
      !document.mozFullScreenElement &&
      !document.webkitFullscreenElement &&
      !document.msFullscreenElement) {
    // Entrar em tela cheia
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) {
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    }
    document.body.classList.add('fullscreen');
  } else {
    // Sair da tela cheia
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
    document.body.classList.remove('fullscreen');
  }
  
  // Atualizar tamanho do canvas após tela cheia
  setTimeout(setCanvasSize, 300);
}

// Detectar mudanças no estado de tela cheia
document.addEventListener('fullscreenchange', handleFullScreenChange);
document.addEventListener('webkitfullscreenchange', handleFullScreenChange);
document.addEventListener('mozfullscreenchange', handleFullScreenChange);
document.addEventListener('MSFullscreenChange', handleFullScreenChange);

function handleFullScreenChange() {
  if (document.fullscreenElement || 
      document.webkitFullscreenElement || 
      document.mozFullScreenElement ||
      document.msFullscreenElement) {
    document.body.classList.add('fullscreen');
  } else {
    document.body.classList.remove('fullscreen');
  }
  
  // Atualizar tamanho do canvas após tela cheia
  setTimeout(setCanvasSize, 300);
}

// Adicionar evento de clique ao botão de tela cheia
document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);

// Ativar tela cheia também em dispositivos móveis ao iniciar o jogo
function checkMobileFullscreen() {
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    // Em dispositivos móveis, exibir em tela cheia automaticamente no primeiro toque
    document.body.addEventListener('touchstart', function autoFullscreen() {
      toggleFullScreen();
      document.body.removeEventListener('touchstart', autoFullscreen);
    }, {once: true});
  }
}

// Início
checkOrientation();
checkMobileFullscreen();
</script>
</body>
</html>