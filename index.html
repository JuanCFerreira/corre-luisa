<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Corre Luisa</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #444;
      touch-action: none;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }    body.fullscreen {
      background: #87ceeb;
    }
    body.fullscreen.night-mode {
      background: #1a1a3a;
    }
    #phone-container {
      width: 800px;
      height: 450px;
      background: #000;
      border-radius: 20px;
      border: 12px solid #333;
      position: relative;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    .fullscreen #phone-container {
      width: 100%;
      height: 100%;
      border-radius: 0;
      border: none;
      box-shadow: none;
    }    #game-area {
      width: 100%;
      height: 100%;
      position: relative;
      background: #87ceeb;
      overflow: hidden;
      transition: background-color 1s;
    }
    .night-mode #game-area {
      background: #1a1a3a;
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block;
    }    #score {
      position: absolute;
      left: 18px;
      top: 18px;
      font-family: Arial, sans-serif;
      font-size: 1.8em;
      color: #fff;
      text-shadow: 1px 2px 4px #333, 0 0 10px #1e90ff;
      z-index: 2;
    }    #day-night-indicator {
      position: absolute;
      left: 18px;
      top: 60px;
      font-family: Arial, sans-serif;
      font-size: 1.2em;
      color: #fff;
      text-shadow: 1px 2px 4px #333, 0 0 10px #1e90ff;
      z-index: 2;
      padding: 5px 10px;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      transition: text-shadow 0.3s, transform 0.3s;
    }
    #gameover {
      position: absolute;
      left: 0; top: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 2em;
      text-align: center;
      z-index: 3;
      display: none;
    }    #gameover button {
      margin-top: 20px;
      font-size: 0.9em;
      padding: 12px 28px;
      border: none;
      border-radius: 10px;
      background: #ffdb58;
      color: #444;
      font-weight: bold;
      box-shadow: 2px 2px 8px #222;
      cursor: pointer;
    }
    #startscreen {
      position: absolute;
      left: 0; top: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #87ceeb, #1e90ff);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 2em;
      text-align: center;
      z-index: 4;
    }
    #startscreen h1 {
      font-size: 2em;
      margin-bottom: 30px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.6);
      animation: pulse 1.5s infinite;
    }
    #startscreen button {
      margin-top: 30px;
      font-size: 1em;
      padding: 15px 40px;
      border: none;
      border-radius: 15px;
      background: #ffdb58;
      color: #444;
      font-weight: bold;
      box-shadow: 3px 3px 10px rgba(0,0,0,0.4);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #startscreen button:hover {
      transform: scale(1.05);
      box-shadow: 4px 4px 12px rgba(0,0,0,0.5);
    }
    #startscreen .character-preview {
      width: 180px;
      height: 180px;
      margin: 20px 0;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      animation: float 3s ease-in-out infinite;
    }
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-15px); }
      100% { transform: translateY(0px); }
    }
    #rotate {
      display: none;
      position: absolute;
      left: 0; top: 0; width: 100%; height: 100%;
      background: #222;
      color: #fff;
      z-index: 5;
      font-family: Arial, sans-serif;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 1.5em;
    }
    #fullscreen-btn {
      position: absolute;
      top: 18px;
      right: 18px;
      width: 40px;
      height: 40px;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      cursor: pointer;
      border: none;
      outline: none;
    }
    #fullscreen-btn:before {
      content: "";
      width: 20px;
      height: 20px;
      border: 2px solid white;
      border-radius: 2px;
      display: block;
    }
    .fullscreen #fullscreen-btn:before {
      width: 16px;
      height: 16px;
    }    @media (max-width: 800px) {
      #phone-container {
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
      }
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
<div id="phone-container">  <div id="game-area">
    <div id="rotate">Por favor, gire o celular para a horizontal (paisagem) para jogar!</div>
    <div id="score">Conchas: 0</div>
    <div id="day-night-indicator"></div>
    <button id="fullscreen-btn" aria-label="Tela cheia"></button>
    <div id="gameover">
      <div id="finalmsg"></div>
      <button onclick="restart()">Jogar novamente</button>
    </div>
    <div id="startscreen">
      <h1>Corre Luisa</h1>
      <div class="character-preview" id="character-preview"></div>
      <p>Ajude Luisa a fugir do jacaré e coletar conchas!</p>
      <button onclick="startGameFromMenu()">Começar!</button>
    </div>
    <canvas id="game"></canvas>
  </div>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function isLandscape() { 
  // Em tela cheia no mobile, verifica a orientação real
  if (document.body.classList.contains('fullscreen') && 
     /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    return window.innerWidth > window.innerHeight;
  }
  return true; // Sempre em paisagem na simulação de celular
}

function setCanvasSize() {
  if (document.body.classList.contains('fullscreen')) {
    // Em tela cheia, usa o tamanho da janela
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  } else {
    // Dimensões fixas para simular um dispositivo móvel
    canvas.width = 800;
    canvas.height = 450;
  }
}
setCanvasSize();
window.addEventListener('resize', setCanvasSize);

let w = () => canvas.width, h = () => canvas.height;
let GROUND_Y = () => h() * 0.82;
let GRAVITY = () => h() * 0.0026;
let JUMP_VELOCITY = () => -h() * 0.042; // Mais alto
let GIRL_W = () => w() * 0.08, GIRL_H = () => h() * 0.32;
let JACARE_W = () => w() * 0.13, JACARE_H = () => h() * 0.23;
let SHELL_SIZE = () => w() * 0.045;
let OBSTACLE_W = () => w() * 0.045, OBSTACLE_H = () => h() * 0.10;
let POWERUP_SIZE = () => w() * 0.06; // Tamanho dos itens de poder

// Constantes para controle da frequência dos itens
const SHELL_FREQUENCY_MIN = 0.45; // Mínimo intervalo para conchas (em larguras de tela)
const SHELL_FREQUENCY_MAX = 0.6;  // Máximo intervalo para conchas
const OBSTACLE_FREQUENCY_MIN = 0.55; // Mínimo intervalo para obstáculos
const OBSTACLE_FREQUENCY_MAX = 0.5;  // Máximo intervalo para obstáculos
const POWERUP_FREQUENCY_MIN = 4.0;   // Mínimo intervalo para power-ups (muito mais raro)
const POWERUP_FREQUENCY_MAX = 6.0;   // Máximo intervalo para power-ups

// Velocidade máxima do jogo (relativa à largura da tela)
const MAX_SPEED = 10;  // Velocidade máxima (dobro da velocidade inicial)

// Duração dos power-ups em milissegundos
const MAGNET_DURATION = 8000;  // Duração do imã: 8 segundos
const SHIELD_DURATION = 6000;  // Duração do escudo: 6 segundos

// Configurações de áudio
const EFFECTS_VOLUME = 0.5; // Volume dos efeitos sonoros (0.0 a 1.0)
const MUSIC_VOLUME = 0.3;   // Volume da música de fundo (0.0 a 1.0)

let girl, jacare, shells, obstacles, score, gameover, bgOffset, speed, touchActive, started;
let powerups = []; // Array para armazenar os itens de poder (imã e escudo)
let magnetActive = false; // Estado do poder imã
let magnetEndTime = 0; // Tempo de término do poder imã
let shieldActive = false; // Estado do poder escudo
let shieldEndTime = 0; // Tempo de término do poder escudo
let lastObstacleX = 0; // Rastrear a posição do último obstáculo
let isNightMode = false; // Controla se o cenário está em modo noturno

// Sprites para animação da Luisa
let luisaSprites = [];
let currentSpriteIndex = 0;
let lastSpriteUpdateTime = 0;
let SPRITE_UPDATE_INTERVAL = 100; // Atualizar sprites a cada 100ms

// Sprites para animação do jacaré
let jacareSprites = [];
let currentJacareSpriteIndex = 0;
let lastJacareSpriteUpdateTime = 0;
let JACARE_SPRITE_UPDATE_INTERVAL = 130; // Atualizar sprites do jacaré a cada 130ms

// Adicionar um array de estrelas fixas (para melhor desempenho)
let stars = [];

// Inicializar estrelas fixas
function initStars() {
  stars = [];
  for (let i = 0; i < 30; i++) {
    stars.push({
      x: Math.random() * w(),
      y: Math.random() * GROUND_Y() * 0.8,
      size: Math.random() * 1.5 + 0.5 // Estrelas menores
    });
  }
}

// Carregar sprites da Luisa
function loadLuisaSprites() {
  luisaSprites = [];
  const totalSprites = 8;
  
  function loadSprite(index) {
    if (index > totalSprites) return;
    
    const img = new Image();
    img.src = `sprites/luisa-runn/${index}.png`;
    img.onload = function() {
      luisaSprites[index-1] = img;
      loadSprite(index + 1);
    };
    img.onerror = function() {
      console.error(`Failed to load sprite ${index}`);
      loadSprite(index + 1);
    };
  }
  
  loadSprite(1);
}

// Carregar sprites do jacaré
function loadJacareSprites() {
  jacareSprites = [];
  const totalSprites = 8;
  
  function loadSprite(index) {
    if (index > totalSprites) return;
    
    const img = new Image();
    img.src = `sprites/aligator-runn/${index}.png`;
    img.onload = function() {
      jacareSprites[index-1] = img;
      loadSprite(index + 1);
    };
    img.onerror = function() {
      console.error(`Failed to load jacare sprite ${index}`);
      loadSprite(index + 1);
    };
  }
  
  loadSprite(1);
}

// Inicia o jogo a partir da tela de menu
function startGameFromMenu() {
  // Esconder a tela de início
  document.getElementById('startscreen').style.display = 'none';
  
  // Mostrar os elementos do jogo
  document.getElementById('score').style.display = '';
  document.getElementById('day-night-indicator').style.display = '';
  
  // Inicializar áudio
  initAudio();
  
  // Iniciar o jogo
  startGame();
}

// Função para inicializar o áudio
function initAudio() {
  // Configurar volume da música de fundo
  const backgroundMusic = document.getElementById('backgroundMusic');
  if (backgroundMusic) {
    backgroundMusic.volume = MUSIC_VOLUME;
    backgroundMusic.play().catch(error => {
      console.log("Reprodução automática da música bloqueada pelo navegador:", error);
    });
  }
  
  // Configurar volume dos efeitos sonoros
  const coinSound = document.getElementById('coinSound');
  if (coinSound) coinSound.volume = EFFECTS_VOLUME;
  
  const powerSound = document.getElementById('powerSound');
  if (powerSound) powerSound.volume = EFFECTS_VOLUME;
  
  // Configurar volume dos sons de loop
  const magnetSound = document.getElementById('magnetSound');
  if (magnetSound) magnetSound.volume = EFFECTS_VOLUME * 2; // Volume um pouco mais baixo para não ser intrusivo
  
  const shieldSound = document.getElementById('shieldSound');
  if (shieldSound) shieldSound.volume = EFFECTS_VOLUME * 2; // Volume um pouco mais baixo para não ser intrusivo
}

// Função para pré-carregar e animar o personagem na tela inicial
function preloadCharacterAnimation() {
  const characterPreview = document.getElementById('character-preview');
  
  // Carregar os sprites para animação na tela inicial
  const previewSprites = [];
  let currentPreviewIndex = 0;
  
  function loadPreviewSprite(index) {
    if (index > 8) {
      // Após carregar todos, inicie a animação
      startPreviewAnimation();
      return;
    }
    
    const img = new Image();
    img.src = `sprites/luisa-runn/${index}.png`;
    img.onload = function() {
      previewSprites[index-1] = img;
      loadPreviewSprite(index + 1);
    };
    img.onerror = function() {
      console.error(`Failed to load preview sprite ${index}`);
      loadPreviewSprite(index + 1);
    };
  }
  
  function startPreviewAnimation() {
    if (previewSprites.length === 0) return;
    
    // Definir a imagem inicial
    characterPreview.style.backgroundImage = `url(${previewSprites[0].src})`;
    
    // Animar os sprites na pré-visualização
    setInterval(() => {
      currentPreviewIndex = (currentPreviewIndex + 1) % previewSprites.length;
      if (previewSprites[currentPreviewIndex]) {
        characterPreview.style.backgroundImage = `url(${previewSprites[currentPreviewIndex].src})`;
      }
    }, 150);
  }
  
  // Iniciar carregamento dos sprites para a pré-visualização
  loadPreviewSprite(1);
}

function startGame() {
  setCanvasSize();  jacare = {
    x: w() * 0.03, // Posição inicial mais à esquerda
    y: GROUND_Y() - JACARE_H() + 12,
    w: JACARE_W(),
    h: JACARE_H()
    // Removido jacare.speed, não é mais usado
  };
  girl = {
    x: jacare.x + jacare.w + w() * 0.30, // Posição inicial mais à direita (aumentado de 0.20 para 0.30)
    y: GROUND_Y() - GIRL_H(),
    vy: 0,
    w: GIRL_W(),
    h: GIRL_H(),
    jumping: false
  };  shells = [];
  obstacles = [];
  powerups = []; // Reiniciar array de itens de poder
  magnetActive = false; // Desativar imã
  shieldActive = false; // Desativar escudo
  score = 0;
  speed = w() * 0.009; // Velocidade inicial (metade da velocidade máxima)
  bgOffset = 0;  started = true; // Agora o jogo está iniciado
  gameover = false;
  // Reiniciar tempos dos poderes
  magnetEndTime = 0;
  shieldEndTime = 0;
  
  // Parar quaisquer sons de loop que possam estar tocando
  stopLoopSound('magnetSound');
  stopLoopSound('shieldSound');
  
  lastObstacleX = 0; // Reiniciar a posição do último obstáculoisNightMode = false; // Iniciar com cenário diurno
  document.body.classList.remove('night-mode'); // Remover classe de modo noturno
  document.getElementById('score').innerText = "Conchas: 0";  document.getElementById('gameover').style.display = 'none';
  
  // Inicializar o indicador dia/noite
  updateDayNightIndicator();
  
  // Inicializar estrelas fixas
  initStars();
  
  // Carregar os sprites da Luisa
  loadLuisaSprites();
  
  // Carregar os sprites do Jacaré
  loadJacareSprites();
  
  // Reiniciar a animação
  currentSpriteIndex = 0;
  currentJacareSpriteIndex = 0;
  lastSpriteUpdateTime = Date.now();
  lastJacareSpriteUpdateTime = Date.now();
  
  spawnShell();
  spawnObstacle();
  spawnPowerup(); // Iniciar geração de itens de poder
  requestAnimationFrame(loop);
}

// Shells (conchas)
function spawnShell() {
  const interval = Math.random() * (w() * SHELL_FREQUENCY_MAX) + w() * SHELL_FREQUENCY_MIN;
  setTimeout(() => {
    if (!gameover && isLandscape()) {
      // Chance de criar um padrão especial de conchas (aproximadamente 20% de chance)
      if (Math.random() < 0.2) {
        createShellPattern();
      } else {
        // Concha individual normal
        shells.push({
          x: w() + SHELL_SIZE(),
          y: GROUND_Y() - SHELL_SIZE() - Math.random() * (h() * 0.15),
          w: SHELL_SIZE(),
          h: SHELL_SIZE()
        });
      }
      spawnShell();
    }
  }, interval / speed * 16);
}

// Função para criar padrões especiais de conchas
function createShellPattern() {
  // Escolher aleatoriamente entre diferentes padrões
  const patternType = Math.floor(Math.random() * 6); // 0-5 para diferentes padrões (adicionamos o padrão LUISA)
  
  switch(patternType) {
    case 0:
      createStraightLinePattern(); // Linha reta horizontal
      break;
    case 1:
      createArcPattern(); // Arco de conchas
      break;
    case 2:
      createZigZagPattern(); // Padrão em zig-zag
      break;
    case 3:
      createDiagonalLinePattern(); // Linha diagonal
      break;
    case 4:
      createInvertedArcPattern(); // Arco invertido de conchas
      break;
    case 5:
      createLuisaTextPattern(); // Texto "LUISA" com conchas
      break;
  }
}

// Criar padrão de linha reta com conchas
function createStraightLinePattern() {
  const shellCount = 5 + Math.floor(Math.random() * 3); // 5 a 7 conchas
  const baseY = GROUND_Y() - SHELL_SIZE() - Math.random() * (h() * 0.15);
  const spacing = SHELL_SIZE() * 1.3; // Espaço entre as conchas
  
  for (let i = 0; i < shellCount; i++) {
    shells.push({
      x: w() + SHELL_SIZE() + (spacing * i),
      y: baseY,
      w: SHELL_SIZE(),
      h: SHELL_SIZE()
    });
  }
}

// Criar padrão de arco com conchas
function createArcPattern() {
  const shellCount = 5 + Math.floor(Math.random() * 4); // 5 a 8 conchas
  const baseX = w() + SHELL_SIZE();
  const radius = h() * 0.15; // Raio do arco
  const centerY = GROUND_Y() - SHELL_SIZE() - radius - Math.random() * (h() * 0.05);
  
  for (let i = 0; i < shellCount; i++) {
    // Calcular posição em um arco semicircular
    const angle = Math.PI * (i / (shellCount - 1)); // De 0 a PI (semicírculo)
    shells.push({
      x: baseX + Math.cos(angle) * radius,
      y: centerY + Math.sin(angle) * radius,
      w: SHELL_SIZE(),
      h: SHELL_SIZE()
    });
  }
}

// Criar padrão de arco invertido com conchas
function createInvertedArcPattern() {
  const shellCount = 5 + Math.floor(Math.random() * 4); // 5 a 8 conchas
  const baseX = w() + SHELL_SIZE();
  const radius = h() * 0.15; // Raio do arco
  const centerY = GROUND_Y() - SHELL_SIZE() - Math.random() * (h() * 0.05); // Posição base mais baixa
  
  for (let i = 0; i < shellCount; i++) {
    // Calcular posição em um arco semicircular invertido
    const angle = Math.PI * (i / (shellCount - 1)); // De 0 a PI (semicírculo)
    shells.push({
      x: baseX + Math.cos(angle) * radius,
      y: centerY - Math.sin(angle) * radius, // Invertendo o sinal para criar o arco invertido
      w: SHELL_SIZE(),
      h: SHELL_SIZE()
    });
  }
}

// Criar padrão de texto "LUISA" com conchas
function createLuisaTextPattern() {
  const baseX = w() + SHELL_SIZE();
  const baseY = GROUND_Y() - SHELL_SIZE() * 5 - Math.random() * (h() * 0.1); // Posição mais alta para o texto
  const letterSpacing = SHELL_SIZE() * 1.2; // Espaçamento entre letras
  const dotSpacing = SHELL_SIZE() * 0.8; // Espaçamento entre pontos de cada letra
  
  // Definir pontos para formar cada letra de "LUISA"
  // Letra L
  const L = [
    {x: 0, y: 0}, // topo
    {x: 0, y: 1}, // meio
    {x: 0, y: 2}, // base
    {x: 1, y: 2}, // base direita
    {x: 2, y: 2}  // base direita mais
  ];
  
  // Letra U
  const U = [
    {x: 0, y: 0}, // topo esquerdo
    {x: 0, y: 1}, // meio esquerdo
    {x: 0, y: 2}, // base esquerdo
    {x: 1, y: 2}, // base meio
    {x: 2, y: 0}, // topo direito
    {x: 2, y: 1}, // meio direito
    {x: 2, y: 2}  // base direito
  ];
  
  // Letra I
  const I = [
    {x: 0, y: 0}, // topo esquerdo
    {x: 1, y: 0}, // topo meio
    {x: 2, y: 0}, // topo direito
    {x: 1, y: 1}, // meio
    {x: 0, y: 2}, // base esquerdo
    {x: 1, y: 2}, // base meio
    {x: 2, y: 2}  // base direito
  ];
  
  // Letra S
  const S = [
    {x: 0, y: 0}, // topo esquerdo
    {x: 1, y: 0}, // topo meio
    {x: 2, y: 0}, // topo direito
    {x: 0, y: 1}, // meio esquerdo
    {x: 1, y: 1}, // meio
    {x: 2, y: 2}, // base direito
    {x: 1, y: 2}, // base meio
    {x: 0, y: 2}  // base esquerdo
  ];
  
  // Letra A
  const A = [
    {x: 0, y: 2}, // base esquerdo
    {x: 0, y: 1}, // meio esquerdo
    {x: 0, y: 0}, // topo esquerdo
    {x: 1, y: 0}, // topo meio
    {x: 2, y: 0}, // topo direito
    {x: 2, y: 1}, // meio direito
    {x: 2, y: 2}, // base direito
    {x: 1, y: 1}  // meio (barra horizontal)
  ];
  
  // Função para criar pontos de uma letra
  function createLetterPoints(letter, offsetX) {
    for (let i = 0; i < letter.length; i++) {
      const point = letter[i];
      shells.push({
        x: baseX + offsetX + point.x * dotSpacing,
        y: baseY + point.y * dotSpacing,
        w: SHELL_SIZE(),
        h: SHELL_SIZE()
      });
    }
  }
  
  // Criar pontos para formar "LUISA"
  createLetterPoints(L, 0);
  createLetterPoints(U, 4 * letterSpacing);
  createLetterPoints(I, 8 * letterSpacing);
  createLetterPoints(S, 12 * letterSpacing);
  createLetterPoints(A, 16 * letterSpacing);
}

// Criar padrão em zig-zag
function createZigZagPattern() {
  const shellCount = 6 + Math.floor(Math.random() * 3); // 6 a 8 conchas
  const baseY = GROUND_Y() - SHELL_SIZE() - (h() * 0.1);
  const spacing = SHELL_SIZE() * 1.3; // Espaço horizontal entre as conchas
  const verticalOffset = SHELL_SIZE() * 1.5; // Quantidade de deslocamento vertical
  
  for (let i = 0; i < shellCount; i++) {
    shells.push({
      x: w() + SHELL_SIZE() + (spacing * i),
      y: baseY + ((i % 2 === 0) ? 0 : -verticalOffset), // Alterna entre duas alturas
      w: SHELL_SIZE(),
      h: SHELL_SIZE()
    });
  }
}

// Criar padrão de linha diagonal
function createDiagonalLinePattern() {
  const shellCount = 5 + Math.floor(Math.random() * 3); // 5 a 7 conchas
  const startY = GROUND_Y() - SHELL_SIZE() - (h() * 0.05);
  const spacing = SHELL_SIZE() * 1.3; // Espaço horizontal entre as conchas
  const slope = SHELL_SIZE() * 1.2; // Inclinação da diagonal
  
  for (let i = 0; i < shellCount; i++) {
    shells.push({
      x: w() + SHELL_SIZE() + (spacing * i),
      y: startY - (slope * i), // Subindo diagonalmente
      w: SHELL_SIZE(),
      h: SHELL_SIZE()
    });
  }
}

// Obstáculos (pedras)
function spawnObstacle() {
  const interval = Math.random() * (w() * OBSTACLE_FREQUENCY_MAX) + w() * OBSTACLE_FREQUENCY_MIN;
  setTimeout(() => {
    if (!gameover && isLandscape()) {
      // Verificar se há espaço suficiente para um novo obstáculo
      const minSpaceBetweenObstacles = w() * 0.5; // Espaço mínimo de 50% da largura da tela
      
      // Se não houver obstáculos ou o último obstáculo já estiver suficientemente distante
      if (obstacles.length === 0 || 
          (lastObstacleX - (w() + OBSTACLE_W())) < -minSpaceBetweenObstacles) {
        
        // Criar novo obstáculo
        const newObstacle = {
          x: w() + OBSTACLE_W(),
          y: GROUND_Y() - OBSTACLE_H() + 8,
          w: OBSTACLE_W(),
          h: OBSTACLE_H()
        };
        
        obstacles.push(newObstacle);
        lastObstacleX = newObstacle.x; // Atualizar a posição do último obstáculo
      }
      
      // Programar próxima verificação
      spawnObstacle();
    }
  }, interval / speed * 13);
}

// Itens de poder (imã e escudo)
function spawnPowerup() {
  // Intervalo muito mais longo para os power-ups (bem mais raros)
  const interval = Math.random() * (w() * POWERUP_FREQUENCY_MAX) + w() * POWERUP_FREQUENCY_MIN;
  setTimeout(() => {
    if (!gameover && isLandscape()) {
      // Tipo aleatório: 0 para imã, 1 para escudo
      const type = Math.floor(Math.random() * 2);
      powerups.push({
        x: w() + POWERUP_SIZE(),
        y: GROUND_Y() - POWERUP_SIZE() - Math.random() * (h() * 0.15),
        w: POWERUP_SIZE(),
        h: POWERUP_SIZE(),
        type: type // 0 = imã, 1 = escudo
      });
      spawnPowerup();
    }
  }, interval / speed * 50); // Multiplicador muito maior para tornar os power-ups bem mais raros
}

function drawBeach() {
  // Cores para o modo dia
  let skyColor = isNightMode ? '#1a1a3a' : '#87ceeb'; // Azul escuro à noite, azul claro de dia
  let seaColor = isNightMode ? '#0a3a70' : '#1e90ff'; // Azul marinho à noite, azul normal de dia
  let sandColor = isNightMode ? '#d4af37' : '#ffdb58'; // Areia mais escura à noite
  let lineColor = isNightMode ? '#bb9930' : '#edd382'; // Linhas mais escuras à noite
  
  // Desenhar céu
  ctx.fillStyle = skyColor;
  ctx.fillRect(0, 0, w(), h());
  
  // Desenhar mar
  ctx.fillStyle = seaColor;
  ctx.fillRect(0, GROUND_Y() - h()*0.06, w(), h()*0.13);
  
  // Desenhar areia
  ctx.fillStyle = sandColor;
  ctx.fillRect(0, GROUND_Y(), w(), h() - GROUND_Y());
  
  // Desenhar linhas na areia
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = 4;
  
  for(let i=0; i<9; i++) {
    let lx = ((bgOffset + i*200) % w());
    ctx.beginPath();
    ctx.moveTo(lx, GROUND_Y() + h()*0.03);
    ctx.lineTo(lx + 70, h());
    ctx.stroke();
  }
  // Adicionar elementos noturnos ou diurnos
  if (isNightMode) {
    // Adicionar estrelas à noite usando o array de estrelas fixas
    for(let i=0; i < stars.length; i++) {
      let star = stars[i];
      
      // Estrela simples sem brilho
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
      ctx.fill();
    }    // Adicionar lua
    ctx.fillStyle = '#f5f5f5';
    ctx.beginPath();
    ctx.arc(w() * 0.85, h() * 0.2, w() * 0.06, 0, Math.PI*2);
    ctx.fill();
    
    // Sombra na lua
    ctx.fillStyle = '#1a1a3a';
    ctx.beginPath();
    ctx.arc(w() * 0.83, h() * 0.18, w() * 0.05, 0, Math.PI*2);
    ctx.fill();
  } else {
    // Adicionar sol
    let sunGradient = ctx.createRadialGradient(
      w() * 0.85, h() * 0.2, 0,
      w() * 0.85, h() * 0.2, w() * 0.08
    );
    sunGradient.addColorStop(0, '#ffff00');
    sunGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
    
    ctx.fillStyle = sunGradient;
    ctx.beginPath();
    ctx.arc(w() * 0.85, h() * 0.2, w() * 0.08, 0, Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(w() * 0.85, h() * 0.2, w() * 0.05, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawGirl() {
  ctx.save();
  ctx.translate(girl.x + girl.w/2, girl.y + 30 + girl.h/2);
  const jumpAmt = girl.jumping ? 0.12 : 0;
  ctx.rotate(jumpAmt * Math.sin(Date.now()/110));
  
  // Efeito de escudo quando ativo
  if (shieldActive) {
    ctx.beginPath();
    ctx.arc(0, 0, girl.w * 1.2, 0, 2 * Math.PI);
    ctx.fillStyle = 'rgba(147, 112, 219, 0.3)';
    ctx.fill();
    
    // Borda animada do escudo
    ctx.strokeStyle = 'rgba(255, 255, 255, ' + (0.5 + Math.sin(Date.now()/150) * 0.5) + ')';
    ctx.lineWidth = 3;
    ctx.stroke();
  }
  
  // Efeito de imã quando ativo
  if (magnetActive) {
    ctx.beginPath();
    // Linhas onduladas ao redor da menina
    for (let i = 0; i < 360; i += 40) {
      const rad = i * Math.PI / 180;
      const wave = Math.sin(Date.now()/200 + i/20) * 5;
      const x1 = Math.cos(rad) * (girl.w * 1.3);
      const y1 = Math.sin(rad) * (girl.w * 1.3);
      const x2 = Math.cos(rad) * (girl.w * 1.6 + wave);
      const y2 = Math.sin(rad) * (girl.w * 1.6 + wave);
      
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.strokeStyle = 'rgba(30, 144, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  // Atualizar a animação do sprite
  const currentTime = Date.now();
  if (currentTime - lastSpriteUpdateTime > SPRITE_UPDATE_INTERVAL) {
    // Avançar para o próximo sprite apenas se a personagem estiver no chão
    if (!girl.jumping) {
      currentSpriteIndex = (currentSpriteIndex + 1) % luisaSprites.length;
    } else {
      // Usar um sprite específico para o pulo (por exemplo, o sprite 3)
      currentSpriteIndex = 2; // Índice 2 corresponde ao 3.png (0-indexed array)
    }
    lastSpriteUpdateTime = currentTime;
  }
  
  // Desenhar sprite da Luisa se estiver carregado
  if (luisaSprites.length > 0 && luisaSprites[currentSpriteIndex]) {
    const sprite = luisaSprites[currentSpriteIndex];
    // Ajustar o tamanho para manter a proporção da imagem
    const spriteRatio = sprite.height / sprite.width;
    const drawWidth = girl.w * 1.5; // Um pouco maior que o retângulo original
    const drawHeight = drawWidth * spriteRatio;
    
    // Centralizar a imagem (considerando o ponto de origem no centro)
    ctx.drawImage(
      sprite, 
      -drawWidth/2, 
      -drawHeight/2, 
      drawWidth, 
      drawHeight
    );
  } else {
    // Fallback para o desenho original se os sprites não estiverem carregados
    ctx.fillStyle = '#ffb6c1';
    ctx.fillRect(-girl.w/2, -girl.h/2, girl.w, girl.h);
    ctx.beginPath();
    ctx.arc(0, -girl.h/2.2, girl.w/2.7, 0, 2 * Math.PI);
    ctx.fillStyle = '#ffe4e1';
    ctx.fill();
    ctx.fillStyle = '#c66900';
    ctx.fillRect(-girl.w/2, girl.h/2 - 8, girl.w*0.20, 10);
    ctx.fillRect(girl.w/2 - girl.w*0.20, girl.h/2 - 8, girl.w*0.20, 10);
    ctx.beginPath();
    ctx.moveTo(-girl.w/2.5, -girl.h/2.2);
    ctx.lineTo(-girl.w/1.8, -girl.h/1.8);
    ctx.lineTo(-girl.w/4, -girl.h/2.8);
    ctx.closePath();
    ctx.fillStyle = '#8b5c2d';
    ctx.fill();
  }
  
  ctx.restore();
}

function drawJacare() {
  ctx.save();
  ctx.translate(jacare.x + jacare.w/2, jacare.y + jacare.h/2);
  
  // Atualizar a animação do sprite do jacaré
  const currentTime = Date.now();
  if (currentTime - lastJacareSpriteUpdateTime > JACARE_SPRITE_UPDATE_INTERVAL) {
    currentJacareSpriteIndex = (currentJacareSpriteIndex + 1) % jacareSprites.length;
    lastJacareSpriteUpdateTime = currentTime;
  }
  
  // Desenhar sprite do jacaré se estiver carregado
  if (jacareSprites.length > 0 && jacareSprites[currentJacareSpriteIndex]) {
    const sprite = jacareSprites[currentJacareSpriteIndex];
    // Ajustar o tamanho para manter a proporção da imagem
    const spriteRatio = sprite.height / sprite.width;
    const drawWidth = jacare.w * 1.5; // Um pouco maior que o retângulo original
    const drawHeight = drawWidth * spriteRatio;
    
    // Centralizar a imagem (considerando o ponto de origem no centro)
    ctx.drawImage(
      sprite, 
      -drawWidth/2, 
      -drawHeight/2, 
      drawWidth, 
      drawHeight
    );
  } else {
    // Fallback para o desenho original se os sprites não estiverem carregados
    ctx.fillStyle = '#228B22';
    ctx.fillRect(-jacare.w/2, -jacare.h/2, jacare.w, jacare.h*0.55);
    ctx.beginPath();
    ctx.ellipse(jacare.w*0.37, -jacare.h*0.1, jacare.w*0.23, jacare.h*0.25, 0, 0, 2*Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-jacare.w/2, jacare.h*0.05);
    ctx.quadraticCurveTo(-jacare.w*0.75, jacare.h*0.07, -jacare.w/2, jacare.h*0.30);
    ctx.lineTo(-jacare.w/2+10, jacare.h*0.10);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(jacare.w*0.47, -jacare.h*0.18, jacare.w*0.06, 0, 2*Math.PI);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(jacare.w*0.50, -jacare.h*0.18, jacare.w*0.025, 0, 2*Math.PI);
    ctx.fillStyle = '#111';
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillRect(jacare.w*0.55, -jacare.h*0.03, 6, 7);
    ctx.fillRect(jacare.w*0.52, 0, 6, 7);
  }
  
  ctx.restore();
}

function drawShell(shell) {
  ctx.save();
  ctx.translate(shell.x + shell.w/2, shell.y + shell.h/2);
  ctx.beginPath();
  ctx.arc(0, 0, shell.w/2.3, 0, Math.PI, true);
  ctx.lineTo(-shell.w/2.3, shell.h/2.7);
  ctx.quadraticCurveTo(0, shell.h/1.7, shell.w/2.3, shell.h/2.7);
  ctx.closePath();
  ctx.fillStyle = '#ffb347';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, shell.h/2.7);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-shell.w/6, 0);
  ctx.lineTo(-shell.w/9, shell.h/2.7);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(shell.w/6, 0);
  ctx.lineTo(shell.w/9, shell.h/2.7);
  ctx.stroke();
  ctx.restore();
}

function drawObstacle(obs) {
  ctx.save();
  ctx.translate(obs.x + obs.w/2, obs.y + obs.h/2);
  ctx.beginPath();
  ctx.ellipse(0, obs.h/5, obs.w/2, obs.h/2.2, 0, 0, 2 * Math.PI);
  ctx.fillStyle = '#888';
  ctx.shadowColor = "#222";
  ctx.shadowBlur = 4;
  ctx.fill();
  ctx.restore();
}

// Desenhar item de poder (imã ou escudo)
function drawPowerup(powerup) {
  ctx.save();
  ctx.translate(powerup.x + powerup.w/2, powerup.y + powerup.h/2);
  
  // Efeito de rotação suave
  ctx.rotate(Date.now() / 800);
  
  if (powerup.type === 0) { // Imã
    // Desenha imã
    ctx.fillStyle = '#1e90ff';
    ctx.beginPath();
    ctx.arc(0, 0, powerup.w/2.5, 0, 2 * Math.PI);
    ctx.fill();
    
    // Ferradura do imã
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(0, -powerup.h/8, powerup.w/4, Math.PI, 0, true);
    ctx.fill();
    
    // Polos do imã
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-powerup.w/4, -powerup.h/5, powerup.w/10, powerup.h/3.5);
    ctx.fillRect(powerup.w/4 - powerup.w/10, -powerup.h/5, powerup.w/10, powerup.h/3.5);
  } else { // Escudo
    // Desenha escudo
    ctx.fillStyle = '#9370db';
    ctx.beginPath();
    ctx.arc(0, 0, powerup.w/2.5, 0, 2 * Math.PI);
    ctx.fill();
    
    // Desenho do escudo
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, powerup.w/4, 0, 2 * Math.PI);
    ctx.stroke();
    
    // Detalhes do escudo
    ctx.beginPath();
    ctx.moveTo(0, -powerup.h/5);
    ctx.lineTo(0, powerup.h/5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-powerup.w/5, 0);
    ctx.lineTo(powerup.w/5, 0);
    ctx.stroke();
  }
  
  // Efeito brilhante
  ctx.shadowColor = powerup.type === 0 ? "#1e90ff" : "#9370db";
  ctx.shadowBlur = 10;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, powerup.w/2.5, 0, 2 * Math.PI);
  ctx.stroke();
  
  ctx.restore();
}

// Desenha indicadores dos poderes ativos
function drawPowerIndicators() {
  // Posição dos indicadores no canto superior direito
  const startX = w() - 20;
  const startY = 20;
  const iconSize = w() * 0.035;
  const spacing = iconSize * 1.5;
  
  // Desenhar ícone do imã se estiver ativo
  if (magnetActive) {
    const timeLeft = (magnetEndTime - Date.now()) / 1000; // Tempo restante em segundos
    drawPowerIcon(startX - iconSize, startY, iconSize, 0, timeLeft, MAGNET_DURATION/1000);
  }
  
  // Desenhar ícone do escudo se estiver ativo
  if (shieldActive) {
    const timeLeft = (shieldEndTime - Date.now()) / 1000; // Tempo restante em segundos
    drawPowerIcon(startX - iconSize, startY + spacing, iconSize, 1, timeLeft, SHIELD_DURATION/1000);
  }
}

// Desenha um ícone de poder com barra de tempo
function drawPowerIcon(x, y, size, type, timeLeft, maxTime) {
  ctx.save();
  ctx.translate(x, y);
  
  // Desenha o círculo de fundo
  ctx.fillStyle = type === 0 ? 'rgba(30, 144, 255, 0.7)' : 'rgba(147, 112, 219, 0.7)';
  ctx.beginPath();
  ctx.arc(0, 0, size, 0, 2 * Math.PI);
  ctx.fill();
  
  // Desenha o ícone
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  
  if (type === 0) { // Imã
    // Ferradura do imã
    ctx.beginPath();
    ctx.arc(0, -size/8, size/3, Math.PI, 0, true);
    ctx.stroke();
    
    // Polos do imã
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-size/3, -size/4, size/6, size/2);
    ctx.fillRect(size/3 - size/6, -size/4, size/6, size/2);
  } else { // Escudo
    ctx.beginPath();
    ctx.arc(0, 0, size/2, 0, 2 * Math.PI);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, -size/2);
    ctx.lineTo(0, size/2);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(-size/2, 0);
    ctx.lineTo(size/2, 0);
    ctx.stroke();
  }
  
  // Desenha barra de tempo
  const percentage = timeLeft / maxTime;
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.arc(0, 0, size * 0.8, -Math.PI/2, -Math.PI/2 + percentage * 2 * Math.PI, false);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

function loop() {
  if (gameover || !isLandscape() || !started) {
    // Continuar a animação mesmo quando não estiver jogando
    requestAnimationFrame(loop);
    return;
  }
  ctx.clearRect(0,0,w(),h());

  bgOffset -= speed * 2;
  if(bgOffset < -w()) bgOffset += w();

  drawBeach();
  // Verificar se os poderes estão ativos
  const currentTime = Date.now();
  if (magnetActive && currentTime > magnetEndTime) {
    magnetActive = false;
    // Parar o som de magnetismo quando o poder terminar
    stopLoopSound('magnetSound');
  }
  if (shieldActive && currentTime > shieldEndTime) {
    shieldActive = false;
    // Parar o som de escudo quando o poder terminar
    stopLoopSound('shieldSound');
  }

  // Menina física
  girl.vy += GRAVITY();
  girl.y += girl.vy;
  if (girl.y + girl.h >= GROUND_Y()) {
    girl.y = GROUND_Y() - girl.h;
    girl.vy = 0;
    girl.jumping = false;
  }
  
  // Ajustar o intervalo de atualização do sprite com base na velocidade do jogo
  // Quanto mais rápido o jogo, mais rápida a animação
  SPRITE_UPDATE_INTERVAL = 180 - (speed * 10); // Mínimo de 80ms em velocidade máxima
  if (SPRITE_UPDATE_INTERVAL < 80) SPRITE_UPDATE_INTERVAL = 80;
  
  // Ajustar também a velocidade da animação do jacaré
  JACARE_SPRITE_UPDATE_INTERVAL = 210 - (speed * 10); // Um pouco mais lenta que a da Luisa
  if (JACARE_SPRITE_UPDATE_INTERVAL < 100) JACARE_SPRITE_UPDATE_INTERVAL = 100;
  
  // Jacaré persegue a menina, mas fica mais afastado
  let dist = girl.x - jacare.x - jacare.w * 0.2;
  let minDist = girl.w * 2.5; // Aumentando a distância mínima para 2.5x a largura da menina
  if (dist > minDist) {
    jacare.x += Math.min(speed * 0.75, dist * 0.05); // Velocidade de perseguição mais lenta
  }
  // Obstáculos
  for (let o of obstacles) o.x -= speed;
  obstacles = obstacles.filter(o => {
    // Manter apenas obstáculos visíveis na tela
    const isVisible = o.x + o.w > 0;
    // Quando um obstáculo sai da tela, atualizar a variável lastObstacleX
    if (!isVisible && lastObstacleX === o.x) {
      lastObstacleX = 0; // Resetar o valor para permitir novos obstáculos
    }
    return isVisible;
  });

  // Colisão menina/obstáculo
  for (let i = 0; i < obstacles.length; i++) {
    let obs = obstacles[i];
    if (rectsCollide(girl, obs)) {
      // Se o escudo estiver ativo, não há colisão com obstáculos
      if (!shieldActive) {
        gameOver("Você tropeçou em uma pedra!");
        return;
      }
    }
  }

  // Power-ups
  for (let p of powerups) p.x -= speed;
  powerups = powerups.filter(p => p.x + p.w > 0);
  // Colisão menina/power-up
  for (let i = powerups.length-1; i >= 0; i--) {
    let p = powerups[i];
    if (rectsCollide(girl, p)) {
      powerups.splice(i, 1);
      
      // Tocar som de poder
      playSound('powerSound');
        if (p.type === 0) { // Imã
        magnetActive = true;
        magnetEndTime = Date.now() + MAGNET_DURATION;
      } else { // Escudo
        shieldActive = true;
        shieldEndTime = Date.now() + SHIELD_DURATION;
      }
    }
  }

  // Shells
  for (let s of shells) s.x -= speed;
  shells = shells.filter(s => s.x + s.w > 0);

  // Efeito do imã de conchas
  if (magnetActive) {
    for (let s of shells) {
      // Calcular distância entre a menina e a concha
      const dx = (girl.x + girl.w/2) - (s.x + s.w/2);
      const dy = (girl.y + girl.h/2) - (s.y + s.h/2);
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      // Se a concha estiver próxima, atraí-la para a menina
      if (distance < w() * 0.3) // Distância de atração: 30% da largura da tela
        s.x += dx * 0.07; // Velocidade de atração
        s.y += dy * 0.07;
    }
  }  // Colisão menina/shell
  for (let i = shells.length-1; i >= 0; i--) {
    let s = shells[i];
    if (rectsCollide(girl,s)) {
      shells.splice(i,1);
      score++;
      document.getElementById('score').innerText = "Conchas: " + score;
      
      // Tocar som de concha
      playSound('coinSound');
      
        // Alternar entre dia e noite a cada 50 conchas
      if (score % 50 === 0) {
        isNightMode = !isNightMode;
        
        // Atualizar classe do body para mudar o fundo em tela cheia
        if (isNightMode) {
          document.body.classList.add('night-mode');
          // Inicializar estrelas quando mudar para modo noturno
          initStars();
        } else {
          document.body.classList.remove('night-mode');
        }
        
        // Efeito visual para transição
        const flashElement = document.createElement('div');
        flashElement.style.position = 'absolute';
        flashElement.style.left = '0';
        flashElement.style.top = '0';
        flashElement.style.zIndex = '5';
        flashElement.style.transition = 'opacity 1.5s';
        document.getElementById('game-area').appendChild(flashElement);        // Remover o flash após a animação
        setTimeout(() => {
          flashElement.style.opacity = '0';
          setTimeout(() => {
            document.getElementById('game-area').removeChild(flashElement);
          }, 1500);
        }, 100);
        
        // Atualizar o indicador dia/noite após a mudança
        updateDayNightIndicator();
      }
      
      // Aumentar velocidade até o limite máximo
      if (speed < MAX_SPEED) {
        speed += w() * 0.00037;
        // Limitar a velocidade ao máximo definido
        if (speed > MAX_SPEED) {
          speed = MAX_SPEED;
        }
      }
      // Jacaré não fica mais rápido!
    }
  }

  // Colisão jacaré/menina
  if (rectsCollide(jacare, girl)) {
    // Se o escudo estiver ativo, não há colisão com o jacaré
    if (!shieldActive) {
      gameOver("O jacaré pegou você!");
      return;
    }
  }

  // Desenha shells
  for (let s of shells) drawShell(s);

  // Desenha obstáculos
  for (let o of obstacles) drawObstacle(o);
  
  // Desenha power-ups
  for (let p of powerups) drawPowerup(p);

  // Desenha personagens
  drawGirl();
  drawJacare();
    // Desenha indicadores dos poderes ativos
  drawPowerIndicators();
  
  // Atualizar o indicador dia/noite
  updateDayNightIndicator();

  requestAnimationFrame(loop);
}

function rectsCollide(a, b) {
  return !(a.x + a.w < b.x + 10 ||
           a.x > b.x + b.w - 10 ||
           a.y + a.h < b.y + 10 ||
           a.y > b.y + b.h - 10);
}

// Função para tocar efeitos sonoros
function playSound(soundId) {
  const sound = document.getElementById(soundId);
  if (sound) {
    // Reiniciar o som se já estiver tocando
    sound.pause();
    sound.currentTime = 0;
    
    // Tocar o som
    sound.play().catch(error => {
      console.log(`Erro ao reproduzir som ${soundId}:`, error);
    });
  }
}

// Função para iniciar som em loop
function startLoopSound(soundId) {
  const sound = document.getElementById(soundId);
  if (sound) {
    sound.currentTime = 0;
    sound.play().catch(error => {
      console.log(`Erro ao iniciar loop de som ${soundId}:`, error);
    });
  }
}

// Função para parar som em loop
function stopLoopSound(soundId) {
  const sound = document.getElementById(soundId);
  if (sound) {
    // Fade out suave antes de parar completamente
    const fadeOutInterval = setInterval(() => {
      // Reduzir volume gradualmente
      if (sound.volume > 0.05) {
        sound.volume -= 0.05;
      } else {
        // Quando o volume estiver bem baixo, parar o som e o intervalo
        sound.pause();
        sound.currentTime = 0;
        // Restaurar o volume original para próxima vez
        sound.volume = EFFECTS_VOLUME;
        clearInterval(fadeOutInterval);
      }
    }, 50);
  }
}

// Controles (Toque ou Tecla)
function jump() {
  if (!girl.jumping && !gameover && isLandscape()) {
    girl.vy = JUMP_VELOCITY();
    girl.jumping = true;
    started = true;
  }
}
canvas.addEventListener('touchstart', function(e){
  e.preventDefault();
  // Evite pular se o toque foi no botão de tela cheia
  const fsButton = document.getElementById('fullscreen-btn');
  const touch = e.touches[0];
  const fsRect = fsButton.getBoundingClientRect();
  
  if (touch.clientX >= fsRect.left && touch.clientX <= fsRect.right &&
      touch.clientY >= fsRect.top && touch.clientY <= fsRect.bottom) {
    return;
  }
  
  jump();
}, {passive:false});
canvas.addEventListener('pointerdown', function(e){
  e.preventDefault();
  // Evite pular se o clique foi no botão de tela cheia
  const fsButton = document.getElementById('fullscreen-btn');
  const fsRect = fsButton.getBoundingClientRect();
  
  if (e.clientX >= fsRect.left && e.clientX <= fsRect.right &&
      e.clientY >= fsRect.top && e.clientY <= fsRect.bottom) {
    return;
  }
  
  jump();
});
window.addEventListener('keydown', function(e){
  if (e.code === "Space" || e.code === "ArrowUp") jump();
});

function gameOver(msg) {
  gameover = true;
  document.getElementById('finalmsg').innerText =
    (msg ? msg+"\n":"") + `Você coletou ${score} conchinha${score==1?'':'s'}!`;
  document.getElementById('gameover').style.display = 'flex';
  
  // Parar todos os efeitos sonoros de loop
  stopLoopSound('magnetSound');
  stopLoopSound('shieldSound');
}

function restart() {
  // Ocultar a tela de game over
  document.getElementById('gameover').style.display = 'none';
  
  // Iniciar o jogo diretamente (sem mostrar a tela inicial)
  startGame();
}

// Orientação tela
function checkOrientation() {
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && 
      document.body.classList.contains('fullscreen')) {
    // Em modo tela cheia no celular, verifica orientação real
    if (!isLandscape()) {
      document.getElementById('rotate').style.display = "flex";
      canvas.style.display = "none";
      document.getElementById('score').style.display = "none";
      document.getElementById('startscreen').style.display = "none";
      document.getElementById('day-night-indicator').style.display = "none";
      return;
    }
  }
  
  // Exibe o jogo
  document.getElementById('rotate').style.display = "none";
  canvas.style.display = "block";
  
  // Se o jogo não foi iniciado ou acabou, exibe a tela adequada
  if (gameover) {
    return;
  } else if (!started) {
    // Mostrar tela inicial
    document.getElementById('startscreen').style.display = "flex";
    // Ocultar elementos do jogo
    document.getElementById('score').style.display = "none";
    document.getElementById('day-night-indicator').style.display = "none";
  } else {
    // Jogo em andamento
    document.getElementById('startscreen').style.display = "none";
    document.getElementById('score').style.display = "block";
    document.getElementById('day-night-indicator').style.display = "block";
  }
}
window.addEventListener('resize', checkOrientation);

// Funções para tela cheia
function toggleFullScreen() {
  if (!document.fullscreenElement && 
      !document.mozFullScreenElement &&
      !document.webkitFullscreenElement &&
      !document.msFullscreenElement) {
    // Entrar em tela cheia
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) {
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    }
    document.body.classList.add('fullscreen');
  } else {
    // Sair da tela cheia
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
    document.body.classList.remove('fullscreen');
  }
  
  // Atualizar tamanho do canvas após tela cheia
  setTimeout(setCanvasSize, 300);
}

// Detectar mudanças no estado de tela cheia
document.addEventListener('fullscreenchange', handleFullScreenChange);
document.addEventListener('webkitfullscreenchange', handleFullScreenChange);
document.addEventListener('mozfullscreenchange', handleFullScreenChange);
document.addEventListener('MSFullscreenChange', handleFullScreenChange);

function handleFullScreenChange() {  if (document.fullscreenElement || 
      document.webkitFullscreenElement || 
      document.mozFullScreenElement ||
      document.msFullscreenElement) {
    document.body.classList.add('fullscreen');
    // Manter a classe night-mode se estiver em modo noturno
    if (isNightMode) {
      document.body.classList.add('night-mode');
    }
  } else {
    document.body.classList.remove('fullscreen');
    // Manter a classe night-mode se estiver em modo noturno
    if (isNightMode) {
      document.body.classList.add('night-mode');
    } else {
      document.body.classList.remove('night-mode');
    }
  }
  
  // Atualizar tamanho do canvas após tela cheia
  setTimeout(setCanvasSize, 300);
}

// Adicionar evento de clique ao botão de tela cheia
document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);

// Ativar tela cheia também em dispositivos móveis ao iniciar o jogo
function checkMobileFullscreen() {
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    // Em dispositivos móveis, exibir em tela cheia automaticamente no primeiro toque
    document.body.addEventListener('touchstart', function autoFullscreen() {
      toggleFullScreen();
      document.body.removeEventListener('touchstart', autoFullscreen);
    }, {once: true});
  }
}

// Início
checkOrientation();
checkMobileFullscreen();
preloadCharacterAnimation(); // Inicializar a animação do personagem na tela inicial

// Inicializar as variáveis do jogo
started = false;
gameover = false;

// Função para atualizar o indicador dia/noite
function updateDayNightIndicator() {
  const indicator = document.getElementById('day-night-indicator');
  
  // Mostrar o indicador apenas quando o jogo está ativo
  if (!started || gameover) {
    indicator.style.display = 'none';
    return;
  } else {
    indicator.style.display = 'block';
  }
  
  const nextCycle = 50 - (score % 50); // Calcular quantas conchas faltam para o próximo ciclo
  
  // Definir ícone e texto apropriados para o modo atual
  let icon = isNightMode ? '🌙' : '☀️';
  let nextIcon = isNightMode ? '☀️' : '🌙';
  let text = isNightMode ? 'Noite' : 'Dia';
  
  // Atualizar o indicador
  indicator.innerHTML = `${icon} ${text} (${nextIcon} em ${nextCycle} conchas)`;
  
  // Adicionar efeito pulsante quando estiver próximo da mudança
  if (nextCycle <= 5) {
    indicator.style.animation = 'pulse 0.8s infinite';
    indicator.style.textShadow = isNightMode ? 
      '0 0 10px rgba(255, 255, 0, 0.8)' : 
      '0 0 10px rgba(147, 112, 219, 0.8)';
  } else {
    indicator.style.animation = 'none';
    indicator.style.textShadow = '1px 2px 4px #333, 0 0 10px #1e90ff';
  }
}

// Atualize as estrelas quando a tela for redimensionada
window.addEventListener('resize', function() {
  if (isNightMode) {
    initStars();
  }
});

// Início
checkOrientation();
checkMobileFullscreen();
preloadCharacterAnimation(); // Inicializar a animação do personagem na tela inicial

// Inicializar as variáveis do jogo
started = false;
gameover = false;
</script>
<audio id="backgroundMusic" loop>
  <source src="songs/background-music.mp3" type="audio/mpeg">
  Seu navegador não suporta o elemento de áudio.
</audio>
<audio id="coinSound">
  <source src="songs/effects/coin.mp3" type="audio/mpeg">
  Seu navegador não suporta o elemento de áudio.
</audio>
<audio id="powerSound">
  <source src="songs/effects/power.mp3" type="audio/mpeg">
  Seu navegador não suporta o elemento de áudio.
</audio>
<audio id="magnetSound" loop>
  <source src="songs/effects/magnet.mp3" type="audio/mpeg">
  Seu navegador não suporta o elemento de áudio.
</audio>
<audio id="shieldSound" loop>
  <source src="songs/effects/shield.mp3" type="audio/mpeg">
  Seu navegador não suporta o elemento de áudio.
</audio>

</body>
</html>